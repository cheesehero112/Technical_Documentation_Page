<!DOCTYPE html>
<html lang="en">
  <meta charset="UTF-8">
  <link rel="stylesheet" href="styles.css">
  <head>
    <title id="title">JavaScript Common Array Methods</title>
  </head>
  <body>
    <header>
      <h1 id="title">JavaScript Common Array Methods</h1>
    </header>
    <nav id="navbar">
      <header id="nav-header">JS Common Array Methods</header>
      <ul>
        <li><a class="nav-link" href="#1)_filter()">1) filter()</a></li>
      </ul>
      <ul>
        <li><a class="nav-link" href="#2)_map()">2) map()</a></li>
      </ul>
      <ul>
        <li><a class="nav-link" href="#3)_reduce()">3) reduce()</a></li>
      </ul>
      <ul>
        <li><a class="nav-link" href="#4)_every()">4) every()</a></li>
      </ul>
      <ul>
        <li><a class="nav-link" href="#5)_forEach()">5) forEach()</a></li>
      </ul>
    </nav>
    <main id="main-doc">
      <section class="main-section" id="1)_filter()">
        <header><h2>1) filter()</h2></header>
        <p>The filter() method creates a shallow copy of a portion of a given array, filtered down to just the elements from the given array that pass the test implemented by the provided function.</p><br>
        <pre class="codeblock"><code>const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word => word.length > 6);

console.log(result);
// expected output: Array ["exuberant", "destruction", "present"]</code></pre>
        <p><h4>Return Value:</h4>A shallow copy of a portion of the given array, filtered down to just the elements from the given array that pass the test implemented by the provided function. If no elements pass the test, an empty array will be returned.</p>
        <li>filter() does not mutate the array on which it is called.</li>
      </section>
      <section class="main-section" id="2)_map()">
         <header><h2>2) map()</h2></header>
         <p>The map() method creates a new array populated with the results of calling a provided function on every element in the calling array.</p><br>
         <pre class="codeblock"><code>const array1 = [1, 4, 9, 16];

// pass a function to map
const map1 = array1.map(x => x * 2);

console.log(map1);
// expected output: Array [2, 8, 18, 32]
</code></pre>
         <p><h4>Return Value:</h4>A new array with each element being the result of the callback function.</p>
      </section>
      <section class="main-section" id="3)_reduce()">
         <header><h2>3) reduce()</h2></header>
         <p>The reduce() method executes a user-supplied "reducer" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.</p><br>
         <pre class="codeblock"><code>const array1 = [1, 2, 3, 4];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
  (previousValue, currentValue) => previousValue + currentValue,
  initialValue
);

console.log(sumWithInitial);
// expected output: 10
</code></pre>
         <p>The first time that the callback is run there is no "return value of the previous calculation". If supplied, an initial value may be used in its place. Otherwise the array element at index 0 is used as the initial value and iteration starts from the next element (index 1 instead of index 0).</p><br>
         <p><h4>Return Value:</h4>The value that results from running the "reducer" callback function to completion over the entire array.</p>
         <p><h4>Behavior during array mutations:</h4>
The reduce() method itself does not mutate the array it is used on. However, it is possible for code inside the callback function to mutate the array. These are the possible scenarios of array mutations and how reduce() behaves in these scenarios:</p>
           <li>If elements are appended to the array after reduce() begins to iterate over the array, the callback function does not iterate over the appended elements.</li><br>
           <li>If existing elements of the array do get changed, the values passed to the callback function will be the values from the time that reduce() was first called on the array.</li><br>
           <li>Array elements that are deleted after the call to reduce() begins and before being iterated over are not visited by reduce().</li>
         
      </section>
      <section class="main-section" id="4)_every()">
         <header><h2>4) every()</h2></header>
         <p>The every() method tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value.</p><br>
         <pre class="codeblock"><code>const isBelowThreshold = (currentValue) => currentValue < 40;

const array1 = [1, 30, 39, 29, 10, 13];

console.log(array1.every(isBelowThreshold));
// expected output: true
</code></pre>
         <p><h4>Return Value:</h4>true if the callbackFn function returns a truthy value for every array element. Otherwise, false.</p>
         <li>every does not mutate the array on which it is called.</li>
      </section>
      <section class="main-section" id="5)_forEach()">
         <header><h2>5) forEach()</h2></header>
         <p>The forEach() method executes a provided function once for each array element.</p><br>
         <pre class="codeblock"><code>const array1 = ['a', 'b', 'c'];
array1.forEach(element => console.log(element));

// expected output: "a"
// expected output: "b"
// expected output: "c"</code></pre>
         <p>forEach() calls a provided callbackFn function once for each element in an array in ascending index order. It is not invoked for index properties that have been deleted or are uninitialized.</p><br>
         <p><h4>Return Value:</h4>Always "undefined".</p>
      </section>
    </main>

  </body>
</html>